import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-DTCYh6sz.js";const t={};function l(r,s){return e(),a("div",null,[...s[0]||(s[0]=[n(`<p>分布式任务调度系统是现代大规模应用架构中的关键组件。与单机调度不同，分布式调度需要解决节点间协调、状态一致性、故障恢复等一系列复杂问题。本文将深入探讨分布式调度的基本模型，包括 Master/Worker 架构、调度中心与执行节点的分工，以及状态存储与一致性保障机制。</p><h2 id="master-worker-架构" tabindex="-1"><a class="header-anchor" href="#master-worker-架构"><span>Master/Worker 架构</span></a></h2><p>Master/Worker 架构是分布式调度系统中最常见的设计模式。这种架构通过将控制逻辑与执行逻辑分离，实现了系统的可扩展性和高可用性。</p><h3 id="master-节点的职责" tabindex="-1"><a class="header-anchor" href="#master-节点的职责"><span>Master 节点的职责</span></a></h3><p>Master 节点作为系统的控制中心，承担着核心的调度职责：</p><ul><li><strong>任务分发</strong>：根据任务的调度策略和执行节点的负载情况，将任务分配给合适的 Worker 节点</li><li><strong>状态监控</strong>：实时监控所有 Worker 节点的运行状态和任务执行情况</li><li><strong>故障处理</strong>：检测节点故障，并进行任务迁移和重新分配</li><li><strong>资源管理</strong>：维护系统资源信息，进行负载均衡</li></ul><p>Master 节点通常需要具备高可用性，可以通过主备模式或集群模式来实现。在主备模式下，只有一个 Master 节点处于活跃状态，其他节点作为备用；在集群模式下，多个 Master 节点协同工作，通过选举机制确定主节点。</p><h3 id="worker-节点的职责" tabindex="-1"><a class="header-anchor" href="#worker-节点的职责"><span>Worker 节点的职责</span></a></h3><p>Worker 节点是任务的实际执行者，主要职责包括：</p><ul><li><strong>任务执行</strong>：接收 Master 节点分配的任务，并执行具体的业务逻辑</li><li><strong>状态上报</strong>：定期向 Master 节点报告自身的运行状态和任务执行进度</li><li><strong>资源反馈</strong>：向 Master 节点反馈当前的资源使用情况</li><li><strong>日志记录</strong>：记录任务执行过程中的详细日志信息</li></ul><p>Worker 节点通常可以动态扩展，根据任务负载的变化增加或减少节点数量。</p><h3 id="通信机制" tabindex="-1"><a class="header-anchor" href="#通信机制"><span>通信机制</span></a></h3><p>Master 和 Worker 节点之间需要建立稳定的通信机制：</p><ul><li><strong>心跳检测</strong>：Worker 节点定期向 Master 节点发送心跳信息，表明自身处于活跃状态</li><li><strong>任务指令</strong>：Master 节点向 Worker 节点发送任务执行指令</li><li><strong>状态反馈</strong>：Worker 节点向 Master 节点反馈任务执行状态</li></ul><p>通信机制的设计需要考虑网络分区、消息丢失等异常情况，确保系统的可靠性。</p><h2 id="调度中心-vs-执行节点" tabindex="-1"><a class="header-anchor" href="#调度中心-vs-执行节点"><span>调度中心 vs 执行节点</span></a></h2><p>在分布式调度系统中，调度中心和执行节点承担着不同的职责，它们之间的合理分工是系统高效运行的关键。</p><h3 id="调度中心的设计原则" tabindex="-1"><a class="header-anchor" href="#调度中心的设计原则"><span>调度中心的设计原则</span></a></h3><p>调度中心作为系统的&quot;大脑&quot;，需要具备以下特性：</p><h4 id="高并发处理能力" tabindex="-1"><a class="header-anchor" href="#高并发处理能力"><span>高并发处理能力</span></a></h4><p>调度中心需要同时处理大量任务的调度请求，因此必须具备高并发处理能力。这通常通过以下方式实现：</p><ul><li><strong>异步处理</strong>：采用异步非阻塞的处理模型，提高系统的吞吐量</li><li><strong>缓存机制</strong>：缓存常用的任务信息和节点状态，减少数据库访问</li><li><strong>批量操作</strong>：对相似的调度操作进行批量处理，减少系统开销</li></ul><h4 id="精确的时间控制" tabindex="-1"><a class="header-anchor" href="#精确的时间控制"><span>精确的时间控制</span></a></h4><p>调度中心需要精确控制任务的执行时间，确保任务在正确的时间点触发。这要求系统具备：</p><ul><li><strong>高精度时钟</strong>：使用高精度的系统时钟，减少时间误差</li><li><strong>时间同步机制</strong>：在分布式环境下，确保各节点间的时间同步</li><li><strong>补偿机制</strong>：对于因系统故障等原因错过执行时间的任务，提供补偿执行机制</li></ul><h4 id="灵活的调度策略" tabindex="-1"><a class="header-anchor" href="#灵活的调度策略"><span>灵活的调度策略</span></a></h4><p>调度中心需要支持多种调度策略，满足不同业务场景的需求：</p><ul><li><strong>时间驱动</strong>：基于 Cron 表达式的定时调度</li><li><strong>事件驱动</strong>：基于特定事件触发的任务调度</li><li><strong>依赖驱动</strong>：基于任务间依赖关系的调度</li></ul><h3 id="执行节点的设计原则" tabindex="-1"><a class="header-anchor" href="#执行节点的设计原则"><span>执行节点的设计原则</span></a></h3><p>执行节点作为任务的实际执行者，需要具备以下特性：</p><h4 id="资源隔离" tabindex="-1"><a class="header-anchor" href="#资源隔离"><span>资源隔离</span></a></h4><p>每个执行节点需要为任务提供独立的运行环境，避免任务间的资源冲突：</p><ul><li><strong>进程隔离</strong>：为每个任务创建独立的进程或线程</li><li><strong>内存隔离</strong>：限制任务的内存使用，防止内存溢出影响其他任务</li><li><strong>文件系统隔离</strong>：为任务提供独立的工作目录</li></ul><h4 id="状态监控" tabindex="-1"><a class="header-anchor" href="#状态监控"><span>状态监控</span></a></h4><p>执行节点需要实时监控任务的执行状态，并及时反馈给调度中心：</p><ul><li><strong>执行进度</strong>：定期上报任务的执行进度</li><li><strong>资源使用</strong>：监控任务的 CPU、内存等资源使用情况</li><li><strong>异常检测</strong>：及时发现任务执行过程中的异常情况</li></ul><h4 id="容错机制" tabindex="-1"><a class="header-anchor" href="#容错机制"><span>容错机制</span></a></h4><p>执行节点需要具备一定的容错能力，确保任务的可靠执行：</p><ul><li><strong>自动重启</strong>：对于意外中断的任务，提供自动重启机制</li><li><strong>断点续传</strong>：对于长时间运行的任务，支持从中断点继续执行</li><li><strong>超时控制</strong>：对任务设置合理的超时时间，避免任务无限期执行</li></ul><h2 id="状态存储与一致性" tabindex="-1"><a class="header-anchor" href="#状态存储与一致性"><span>状态存储与一致性</span></a></h2><p>在分布式调度系统中，状态存储与一致性保障是确保系统可靠性的关键因素。</p><h3 id="状态存储的设计" tabindex="-1"><a class="header-anchor" href="#状态存储的设计"><span>状态存储的设计</span></a></h3><p>分布式调度系统需要存储大量的状态信息，包括：</p><h4 id="任务状态" tabindex="-1"><a class="header-anchor" href="#任务状态"><span>任务状态</span></a></h4><ul><li>任务的基本信息（名称、描述、执行逻辑等）</li><li>任务的调度策略（Cron 表达式、执行时间等）</li><li>任务的执行状态（待执行、执行中、已完成等）</li><li>任务的执行历史（执行时间、执行结果等）</li></ul><h4 id="节点状态" tabindex="-1"><a class="header-anchor" href="#节点状态"><span>节点状态</span></a></h4><ul><li>节点的基本信息（IP 地址、端口号等）</li><li>节点的运行状态（在线、离线、忙碌等）</li><li>节点的资源信息（CPU 使用率、内存使用率等）</li></ul><h4 id="系统配置" tabindex="-1"><a class="header-anchor" href="#系统配置"><span>系统配置</span></a></h4><ul><li>系统的基本配置信息</li><li>调度策略配置</li><li>安全配置信息</li></ul><h3 id="一致性保障机制" tabindex="-1"><a class="header-anchor" href="#一致性保障机制"><span>一致性保障机制</span></a></h3><p>在分布式环境下，确保状态信息的一致性是一个复杂的问题。常用的保障机制包括：</p><h4 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h4><p>在更新共享状态时，使用分布式锁确保同一时间只有一个节点可以修改状态：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 伪代码示例</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">DistributedLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DistributedLock</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;/locks/task_state&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">acquire</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 更新任务状态</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    updateTaskState</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(taskId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> newState)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">release</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="事务机制" tabindex="-1"><a class="header-anchor" href="#事务机制"><span>事务机制</span></a></h4><p>对于需要保证原子性的操作，使用分布式事务机制：</p><ul><li><strong>两阶段提交（2PC）</strong>：经典的分布式事务协议</li><li><strong>TCC（Try-Confirm-Cancel）</strong>：补偿型事务模式</li><li><strong>Saga</strong>：长事务的解决方案</li></ul><h4 id="版本控制" tabindex="-1"><a class="header-anchor" href="#版本控制"><span>版本控制</span></a></h4><p>为状态信息添加版本号，通过版本检查避免并发更新冲突：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 伪代码示例</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> updateTaskState</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> taskId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TaskState</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> newState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> version) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 检查版本号是否匹配</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getCurrentVersion</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(taskId) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> version) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 版本不匹配，更新失败</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 执行更新操作</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    doUpdateTaskState</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(taskId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> newState)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数据存储方案" tabindex="-1"><a class="header-anchor" href="#数据存储方案"><span>数据存储方案</span></a></h3><p>根据系统规模和性能要求，可以选择不同的数据存储方案：</p><h4 id="关系型数据库" tabindex="-1"><a class="header-anchor" href="#关系型数据库"><span>关系型数据库</span></a></h4><p>适用于数据量较小、一致性要求高的场景：</p><ul><li><strong>优势</strong>：支持 ACID 特性，数据一致性好</li><li><strong>劣势</strong>：扩展性有限，性能瓶颈明显</li></ul><h4 id="nosql-数据库" tabindex="-1"><a class="header-anchor" href="#nosql-数据库"><span>NoSQL 数据库</span></a></h4><p>适用于数据量大、对一致性要求相对较低的场景：</p><ul><li><strong>优势</strong>：扩展性好，性能高</li><li><strong>劣势</strong>：最终一致性，可能丢失部分数据</li></ul><h4 id="混合存储" tabindex="-1"><a class="header-anchor" href="#混合存储"><span>混合存储</span></a></h4><p>结合关系型数据库和 NoSQL 数据库的优势，将不同类型的数据存储在不同的系统中：</p><ul><li>核心状态信息存储在关系型数据库中</li><li>日志和历史数据存储在 NoSQL 数据库中</li></ul><h2 id="故障处理与恢复" tabindex="-1"><a class="header-anchor" href="#故障处理与恢复"><span>故障处理与恢复</span></a></h2><p>分布式调度系统必须具备完善的故障处理与恢复机制：</p><h3 id="节点故障检测" tabindex="-1"><a class="header-anchor" href="#节点故障检测"><span>节点故障检测</span></a></h3><p>通过心跳机制检测节点的存活状态：</p><ul><li><strong>心跳超时</strong>：超过一定时间未收到心跳信息，认为节点故障</li><li><strong>多次确认</strong>：避免网络抖动导致的误判</li><li><strong>自动隔离</strong>：将故障节点自动从调度池中移除</li></ul><h3 id="任务迁移机制" tabindex="-1"><a class="header-anchor" href="#任务迁移机制"><span>任务迁移机制</span></a></h3><p>当执行节点发生故障时，系统需要将未完成的任务迁移到其他节点：</p><ul><li><strong>状态检查</strong>：确认任务的实际执行状态</li><li><strong>重新分配</strong>：将任务分配给健康的节点</li><li><strong>执行恢复</strong>：在新节点上恢复任务执行</li></ul><h3 id="数据恢复" tabindex="-1"><a class="header-anchor" href="#数据恢复"><span>数据恢复</span></a></h3><p>系统需要定期备份关键数据，并提供数据恢复机制：</p><ul><li><strong>定期备份</strong>：对任务配置、执行历史等重要数据进行定期备份</li><li><strong>增量同步</strong>：实时同步关键状态变更</li><li><strong>快速恢复</strong>：在系统故障后能够快速恢复服务</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>分布式调度的基本模型为构建高可用、可扩展的任务调度系统提供了理论基础。Master/Worker 架构通过合理的职责分工，实现了控制逻辑与执行逻辑的分离；调度中心与执行节点的协同工作，确保了任务的准确调度和可靠执行；状态存储与一致性保障机制，则为系统的稳定性提供了坚实的基础。</p><p>在实际应用中，我们需要根据具体的业务需求和技术条件，选择合适的架构模式和实现方案。随着云原生技术的发展，容器化和微服务架构为分布式调度系统带来了新的机遇和挑战，我们需要持续关注技术发展趋势，不断优化和完善系统设计。</p><p>在下一章中，我们将通过实际代码示例，演示如何从零开始实现一个简单的分布式调度系统。</p>`,86)])])}const d=i(t,[["render",l]]),o=JSON.parse('{"path":"/posts/schedule/003-1-1-3-basic-model-of-distributed-scheduling.html","title":"分布式调度的基本模型","lang":"zh-CN","frontmatter":{"title":"分布式调度的基本模型","date":"2025-08-30T00:00:00.000Z","categories":["Schedule"],"tags":["schedule"],"published":true,"description":"分布式任务调度系统是现代大规模应用架构中的关键组件。与单机调度不同，分布式调度需要解决节点间协调、状态一致性、故障恢复等一系列复杂问题。本文将深入探讨分布式调度的基本模型，包括 Master/Worker 架构、调度中心与执行节点的分工，以及状态存储与一致性保障机制。 Master/Worker 架构 Master/Worker 架构是分布式调度系统中...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式调度的基本模型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-07T09:06:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/blog-middleware/posts/schedule/003-1-1-3-basic-model-of-distributed-scheduling.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"分布式调度的基本模型"}],["meta",{"property":"og:description","content":"分布式任务调度系统是现代大规模应用架构中的关键组件。与单机调度不同，分布式调度需要解决节点间协调、状态一致性、故障恢复等一系列复杂问题。本文将深入探讨分布式调度的基本模型，包括 Master/Worker 架构、调度中心与执行节点的分工，以及状态存储与一致性保障机制。 Master/Worker 架构 Master/Worker 架构是分布式调度系统中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-07T09:06:09.000Z"}],["meta",{"property":"article:tag","content":"schedule"}],["meta",{"property":"article:published_time","content":"2025-08-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-07T09:06:09.000Z"}]]},"git":{"createdTime":1756739272000,"updatedTime":1757235969000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":2,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":8.5,"words":2551},"filePathRelative":"posts/schedule/003-1-1-3-basic-model-of-distributed-scheduling.md","excerpt":"<p>分布式任务调度系统是现代大规模应用架构中的关键组件。与单机调度不同，分布式调度需要解决节点间协调、状态一致性、故障恢复等一系列复杂问题。本文将深入探讨分布式调度的基本模型，包括 Master/Worker 架构、调度中心与执行节点的分工，以及状态存储与一致性保障机制。</p>\\n<h2>Master/Worker 架构</h2>\\n<p>Master/Worker 架构是分布式调度系统中最常见的设计模式。这种架构通过将控制逻辑与执行逻辑分离，实现了系统的可扩展性和高可用性。</p>\\n<h3>Master 节点的职责</h3>\\n<p>Master 节点作为系统的控制中心，承担着核心的调度职责：</p>","autoDesc":true}');export{d as comp,o as data};

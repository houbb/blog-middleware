import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as n,o}from"./app-BqzWBAFn.js";const r={};function s(e,l){return o(),t("div",null,[...l[0]||(l[0]=[n('<h1 id="《消息队列-从入门到精通》目录" tabindex="-1"><a class="header-anchor" href="#《消息队列-从入门到精通》目录"><span><strong>《消息队列：从入门到精通》目录</strong></span></a></h1><h2 id="第一部分-基础篇-打好地基" tabindex="-1"><a class="header-anchor" href="#第一部分-基础篇-打好地基"><span><strong>第一部分 基础篇：打好地基</strong></span></a></h2><ol><li><p><strong>为什么需要消息队列？</strong></p><ul><li>系统间通信方式对比（同步调用 vs 异步调用）</li><li>解耦、异步、削峰填谷</li><li>MQ 的优势与风险</li></ul></li><li><p><strong>消息队列的基本概念</strong></p><ul><li>消息、队列、主题、消费者</li><li>点对点模型 vs 发布订阅模型</li><li>Push vs Pull 消费模式</li></ul></li><li><p><strong>消息队列的核心要素</strong></p><ul><li>生产者、Broker、消费者</li><li>消息持久化</li><li>消费确认与重试机制</li></ul></li><li><p><strong>消息可靠性与一致性</strong></p><ul><li>至少一次、至多一次、精确一次</li><li>消息丢失、重复、乱序问题</li><li>幂等性设计</li></ul></li></ol><hr><h2 id="第二部分-实战篇-从零实现一个消息队列" tabindex="-1"><a class="header-anchor" href="#第二部分-实战篇-从零实现一个消息队列"><span><strong>第二部分 实战篇：从零实现一个消息队列</strong></span></a></h2><ol start="5"><li><p><strong>最小可用消息队列</strong></p><ul><li>用内存队列实现生产与消费</li><li>多线程模型</li><li>简单 ACK 机制</li></ul></li><li><p><strong>持久化与存储</strong></p><ul><li>文件存储 vs 数据库存储</li><li>顺序写与刷盘机制</li><li>日志分段与索引</li></ul></li><li><p><strong>订阅与分发机制</strong></p><ul><li>点对点 vs 发布订阅模式实现</li><li>消费组设计</li><li>消息路由</li></ul></li><li><p><strong>高可用与容错</strong></p><ul><li>主从复制</li><li>Broker 集群设计</li><li>消费者负载均衡</li></ul></li></ol><hr><h2 id="第三部分-框架篇-主流-mq-深度解析" tabindex="-1"><a class="header-anchor" href="#第三部分-框架篇-主流-mq-深度解析"><span><strong>第三部分 框架篇：主流 MQ 深度解析</strong></span></a></h2><ol start="9"><li><p><strong>RabbitMQ</strong></p><ul><li>AMQP 协议与架构</li><li>Exchange、Queue、Binding 模型</li><li>可靠性保证与事务机制</li><li>典型应用场景</li></ul></li><li><p><strong>Kafka</strong></p><ul><li>Partition 与 Consumer Group 模型</li><li>零拷贝与高吞吐原理</li><li>ISR 副本机制</li><li>Kafka Streams 与实时处理</li></ul></li><li><p><strong>RocketMQ</strong></p><ul><li>基于 Topic 与 Tag 的设计</li><li>顺序消息、延时消息</li><li>事务消息实现</li><li>金融、电商场景应用</li></ul></li><li><p><strong>Pulsar</strong></p><ul><li>分层架构（Broker + BookKeeper + ZooKeeper）</li><li>多租户与分区主题</li><li>存算分离与无限消息保留</li><li>与 Kafka 的对比</li></ul></li><li><p><strong>其他 MQ 框架简析</strong></p><ul><li>ActiveMQ</li><li>Redis Stream</li><li>ZeroMQ</li></ul></li></ol><hr><h2 id="第四部分-高级篇-深入消息队列的核心机制" tabindex="-1"><a class="header-anchor" href="#第四部分-高级篇-深入消息队列的核心机制"><span><strong>第四部分 高级篇：深入消息队列的核心机制</strong></span></a></h2><ol start="14"><li><p><strong>消息投递与确认机制</strong></p><ul><li>ACK、NACK、重试</li><li>死信队列（DLQ）</li><li>重复消费与幂等性设计</li></ul></li><li><p><strong>消息顺序与事务性</strong></p><ul><li>全局顺序 vs 分区顺序</li><li>分布式事务消息（RocketMQ / Kafka 实践）</li><li>TCC/Saga 与 MQ 的结合</li></ul></li><li><p><strong>消息路由与过滤</strong></p><ul><li>广播、单播、组播</li><li>标签过滤与消息选择器</li><li>精准投递</li></ul></li><li><p><strong>高并发与性能优化</strong></p><ul><li>批量发送与批量消费</li><li>零拷贝与 mmap</li><li>内核参数优化（Linux IO/网络优化）</li></ul></li><li><p><strong>安全与隔离</strong></p><ul><li>权限控制与 ACL</li><li>消息加密</li><li>多租户与隔离策略</li></ul></li></ol><hr><h2 id="第五部分-实践篇-mq-在生产环境的落地" tabindex="-1"><a class="header-anchor" href="#第五部分-实践篇-mq-在生产环境的落地"><span><strong>第五部分 实践篇：MQ 在生产环境的落地</strong></span></a></h2><ol start="19"><li><p><strong>典型应用场景</strong></p><ul><li>电商系统：订单、库存、支付解耦</li><li>日志收集与大数据处理</li><li>异步通知与任务调度</li><li>IoT 与实时监控</li></ul></li><li><p><strong>运维与监控</strong></p><ul><li>MQ 的常见故障排查</li><li>性能指标（TPS、延迟、堆积量）</li><li>运维平台与可视化（Kafka Manager、RocketMQ Console）</li></ul></li><li><p><strong>架构实战案例</strong></p><ul><li>高并发秒杀系统的 MQ 设计</li><li>跨数据中心消息同步</li><li>消息队列与微服务体系整合</li></ul></li></ol><hr><h2 id="第六部分-展望篇-未来趋势" tabindex="-1"><a class="header-anchor" href="#第六部分-展望篇-未来趋势"><span><strong>第六部分 展望篇：未来趋势</strong></span></a></h2><ol start="22"><li><p><strong>MQ 与云原生</strong></p><ul><li>云上的消息队列服务（AWS SQS、阿里云 RocketMQ、Pulsar on K8s）</li><li>Serverless 与 MQ 的结合</li><li>Operator 管理模式</li></ul></li><li><p><strong>MQ 与事件驱动架构</strong></p><ul><li>事件溯源（Event Sourcing）</li><li>CQRS 模式与消息队列</li><li>与 Kafka Streams / Flink 的集成</li></ul></li><li><p><strong>总结与学习路径</strong></p><ul><li>从零到精通的学习方法</li><li>框架选型思路</li><li>从工程师到架构师的 MQ 思维</li></ul></li></ol><hr><p>📌 <strong>设计思路</strong>：</p><ul><li>每个 MQ 框架章节都包含：<strong>架构图 + 核心原理 + Demo 示例 + 优缺点总结</strong>。</li><li>读者能先自己手写一个迷你 MQ，再去理解 RabbitMQ/Kafka/RocketMQ/Pulsar。</li><li>最后结合生产案例和未来趋势，形成完整的 MQ 认知体系。</li></ul>',21)])])}const g=i(r,[["render",s]]),u=JSON.parse('{"path":"/posts/mq/index-desc.html","title":"《消息队列：从入门到精通》目录","lang":"zh-CN","frontmatter":{"description":"《消息队列：从入门到精通》目录 第一部分 基础篇：打好地基 为什么需要消息队列？ 系统间通信方式对比（同步调用 vs 异步调用） 解耦、异步、削峰填谷 MQ 的优势与风险 消息队列的基本概念 消息、队列、主题、消费者 点对点模型 vs 发布订阅模型 Push vs Pull 消费模式 消息队列的核心要素 生产者、Broker、消费者 消息持久化 消费确...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《消息队列：从入门到精通》目录\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-01T14:56:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/blog-middleware/posts/mq/index-desc.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"《消息队列：从入门到精通》目录"}],["meta",{"property":"og:description","content":"《消息队列：从入门到精通》目录 第一部分 基础篇：打好地基 为什么需要消息队列？ 系统间通信方式对比（同步调用 vs 异步调用） 解耦、异步、削峰填谷 MQ 的优势与风险 消息队列的基本概念 消息、队列、主题、消费者 点对点模型 vs 发布订阅模型 Push vs Pull 消费模式 消息队列的核心要素 生产者、Broker、消费者 消息持久化 消费确..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-01T14:56:59.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-01T14:56:59.000Z"}]]},"git":{"createdTime":1756738619000,"updatedTime":1756738619000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":3.14,"words":941},"filePathRelative":"posts/mq/index-desc.md","excerpt":"\\n<h2><strong>第一部分 基础篇：打好地基</strong></h2>\\n<ol>\\n<li>\\n<p><strong>为什么需要消息队列？</strong></p>\\n<ul>\\n<li>系统间通信方式对比（同步调用 vs 异步调用）</li>\\n<li>解耦、异步、削峰填谷</li>\\n<li>MQ 的优势与风险</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>消息队列的基本概念</strong></p>\\n<ul>\\n<li>消息、队列、主题、消费者</li>\\n<li>点对点模型 vs 发布订阅模型</li>\\n<li>Push vs Pull 消费模式</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>消息队列的核心要素</strong></p>\\n<ul>\\n<li>生产者、Broker、消费者</li>\\n<li>消息持久化</li>\\n<li>消费确认与重试机制</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>消息可靠性与一致性</strong></p>\\n<ul>\\n<li>至少一次、至多一次、精确一次</li>\\n<li>消息丢失、重复、乱序问题</li>\\n<li>幂等性设计</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{g as comp,u as data};
